<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>HUT 3 – AR Candy Catcher (Game)</title>
  <style>
    :root{ --brand:#111827; --accent:#ff3e7f; --good:#16a34a; --bad:#ef4444; }
    html,body{margin:0;padding:0;height:100%;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:#fff}
    #app{position:fixed;inset:0;overflow:hidden;background:#000}
    video#cam{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);display:none}
    canvas#game{position:absolute;inset:0;width:100%;height:100%}
    .hud{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:12px 14px;pointer-events:none;z-index:3}
    .badge{pointer-events:auto;background:rgba(0,0,0,.55);color:#fff;padding:6px 10px;border-radius:12px;font-weight:600;backdrop-filter:blur(6px)}
    .face{pointer-events:auto;background:rgba(0,0,0,.55);color:#fff;padding:6px 10px;border-radius:12px;font-weight:600;backdrop-filter:blur(6px);margin-left:8px}
    .score{font-size:18px}
    .timer{font-variant-numeric:tabular-nums}
    .controls{position:absolute;right:12px;bottom:12px;display:flex;gap:8px;z-index:3}
    button{pointer-events:auto;border:none;border-radius:999px;padding:10px 14px;background:var(--accent);color:#fff;font-weight:700;box-shadow:0 8px 24px rgba(0,0,0,.3);cursor:pointer}
    button.secondary{background:rgba(0,0,0,.55)}
    .frame{position:absolute;inset:0;border:10px solid var(--brand); box-shadow: inset 0 0 0 2px rgba(255,255,255,.06); pointer-events:none}
    .logo{position:absolute;left:24px;bottom:24px;pointer-events:none;padding:6px 10px;z-index:3}
    .logo img{display:block;height:56px}

    .end{position:absolute;inset:0;display:none;place-items:center;background:linear-gradient(0deg,rgba(0,0,0,.75),rgba(0,0,0,.35));z-index:4}
    .end.active{display:grid}
    .end .card{background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.1);border-radius:16px;padding:20px;max-width:520px;color:#fff}
    .end .card h2{margin:0 0 8px 0}
    .end .input{display:flex;gap:10px;margin-top:10px}
    .end .input input{flex:1;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.15);background:rgba(0,0,0,.4);color:#fff}
    .small{font-size:12px;opacity:.8;margin-top:8px}

    .toast{position:absolute;left:50%;bottom:84px;transform:translateX(-50%);background:rgba(0,0,0,.7);color:#fff;padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.15);display:none;z-index:5}
    .toast.show{display:block}
  </style>
</head>
<body>
  <div id="app">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="game"></canvas>

    <div class="hud">
      <div style="display:flex;gap:8px;align-items:center">
        <div class="badge score">Score: <span id="score">0</span></div>
        <div id="faceStatus" class="face">Face: —</div>
      </div>
      <div class="badge timer">Time: <span id="time">30</span>s</div>
    </div>

    <div class="controls">
      <button id="btnStart">Start</button>
      <button id="btnMute" class="secondary">Mute</button>
      <button id="btnDebug" class="secondary">Debug</button>
    </div>

    <div class="frame"></div>
    <div class="logo">
      <img src="https://hut-3.com/wp-content/themes/hut3/images/logo-hut3.svg" alt="HUT 3 logo" />
    </div>

    <div id="end" class="end">
      <div class="card">
        <h2>Great job! Your score: <span id="finalScore">0</span></h2>
        <p>Enter the prize draw: submit your email with your score.</p>
        <div class="input">
          <input id="email" type="email" placeholder="you@company.com" required />
          <button id="submitScore">Submit</button>
        </div>
        <p class="small">By submitting you agree to the prize draw terms and that HUT 3 may contact you about marketing services. You can unsubscribe anytime.</p>
      </div>
    </div>

    <div id="toast" class="toast"></div>
  </div>

  <script type="module">
    import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/vision_bundle.mjs";

    // ---------- Elements ----------
    const video = document.getElementById('cam');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const timeEl = document.getElementById('time');
    const end = document.getElementById('end');
    const finalScoreEl = document.getElementById('finalScore');
    const btnStart = document.getElementById('btnStart');
    const btnMute = document.getElementById('btnMute');
    const btnDebug = document.getElementById('btnDebug');
    const toast = document.getElementById('toast');
    const faceStatus = document.getElementById('faceStatus');

    // ---------- Toast helper ----------
    function showToast(msg, ms=2200){ toast.textContent = msg; toast.classList.add('show'); clearTimeout(showToast._t); showToast._t = setTimeout(()=>toast.classList.remove('show'), ms); }

    // ---------- Audio ----------
    let audioCtx = null; let muted=false;
    function ensureAudio(){ if(!audioCtx){ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } if(audioCtx.state==='suspended'){ audioCtx.resume(); } }
    function playPop(){ if(muted) return; try{ ensureAudio(); const t=audioCtx.currentTime; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(800,t); o.frequency.exponentialRampToValueAtTime(220,t+0.12); g.gain.setValueAtTime(0.001,t); g.gain.exponentialRampToValueAtTime(0.28,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.16); o.connect(g).connect(audioCtx.destination); o.start(t); o.stop(t+0.16);}catch(e){} }

    // ---------- State ----------
    let faceLandmarker=null; let running=false; let showDebug=false;
    let score=0; let timeLeft=30; let timerId=null; let rafId=null;
    let sweets=[]; let lastSpawn=0; let SPAWN_EVERY=1000; // ms start slower
    const MAX_SWEETS=5; const OPEN_THRESHOLD=0.065; // mouth open gate

    // Pointer fallback
    let usePointerMode=false; const pointer={x:innerWidth/2,y:innerHeight/2,down:false};

    // ---------- Helpers ----------
    function resize(){ canvas.width = video.videoWidth || innerWidth; canvas.height = video.videoHeight || innerHeight; }
    function secureContextOK(){ return (location.protocol==='https:' || location.hostname==='localhost'); }

    async function initCamera(){
      if(!secureContextOK()) throw new Error('InsecureContext');
      const gum = navigator.mediaDevices?.getUserMedia; if(!gum) throw new Error('getUserMedia not supported');
      const stream = await gum.call(navigator.mediaDevices,{ video:{ facingMode:'user', width:{ideal:1280}, height:{ideal:720}}, audio:false});
      video.srcObject = stream;
      await new Promise(res=>{ if(video.readyState>=1) return res(); video.onloadedmetadata=res; });
      await video.play(); video.style.display='block'; resize(); window.addEventListener('resize', resize);
    }

    async function initFace(){
      if(faceLandmarker) return;
      const filesetResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/wasm");
      faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver,{ baseOptions:{ modelAssetPath:"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/wasm/face_landmarker.task" }, runningMode:'VIDEO', numFaces:1, outputFaceBlendshapes:false, outputFacialTransformationMatrixes:false });
    }

    function mouthOpenMetric(lm){ const U=lm[13], L=lm[14], nose=lm[1], chin=lm[152]; const mouthGap=Math.hypot(U.x-L.x,U.y-L.y); const faceLen=Math.hypot(nose.x-chin.x,nose.y-chin.y); return mouthGap/faceLen; }
    function mouthCenter(lm){ const U=lm[13], L=lm[14]; return { x:(U.x+L.x)/2, y:(U.y+L.y)/2 }; }
    function worldToCanvas(norm){ return { x:(1-norm.x)*canvas.width, y:norm.y*canvas.height }; }

    function spawnSweet(){ const size=Math.random()*50+60; const x=Math.random()*canvas.width; const speed=Math.random()*60+120; const rot=Math.random()*Math.PI*2; const rotSpeed=(Math.random()*2-1)*1.5; const types=['🍬','🍭','🍫','🍪']; const t=types[Math.floor(Math.random()*types.length)]; sweets.push({x,y:-40,size,speed,rot,rotSpeed,t,hit:false,hitTime:0,scale:1,alpha:1}); }

    function updateAndDrawSweets(dt, now){ ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; for(let i=sweets.length-1;i>=0;i--){ const s=sweets[i]; if(s.hit){ const p=Math.min(1,(now-s.hitTime)/220); s.scale=1+0.6*p; s.alpha=1-p; s.rot+=s.rotSpeed*dt*3; if(p>=1){ sweets.splice(i,1); continue; } } else { s.y+=s.speed*dt; s.rot+=s.rotSpeed*dt; if(s.y - s.size > canvas.height){ sweets.splice(i,1); continue; } } ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.rot); ctx.globalAlpha=s.alpha??1; ctx.font=`${Math.floor(s.size*(s.scale??1))}px system-ui`; ctx.fillText(s.t,0,0); ctx.restore(); } ctx.restore(); }

    function drawMouthCircle(mx,my,r){ ctx.save(); ctx.strokeStyle='rgba(0,255,180,.9)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(mx,my,r,0,Math.PI*2); ctx.stroke(); ctx.restore(); }

    function collideWithMouth(mx,my,r, now){ for(let i=sweets.length-1;i>=0;i--){ const s=sweets[i]; if(s.hit) continue; const dx=s.x-mx, dy=s.y-my; if(Math.hypot(dx,dy)<r){ s.hit=true; s.hitTime=now; s.alpha=1; s.scale=1; s.rotSpeed*=2; score++; scoreEl.textContent=score; playPop(); if(navigator.vibrate){ try{ navigator.vibrate(10);}catch(e){} } } } }

    // ---------- Game loop ----------
    function start(){
      end.classList.remove('active');
      score=0; timeLeft=30; sweets=[]; scoreEl.textContent=score; timeEl.textContent=timeLeft; running=true; lastSpawn=performance.now(); SPAWN_EVERY=1000;
      if(timerId) clearInterval(timerId);
      timerId = setInterval(()=>{ timeLeft--; timeEl.textContent=timeLeft; if(timeLeft%5===0){ SPAWN_EVERY=Math.max(550,SPAWN_EVERY-90);} if(timeLeft<=0) stop(); },1000);
      if(rafId) cancelAnimationFrame(rafId);
      tick();
    }

    function stop(){ running=false; cancelAnimationFrame(rafId); clearInterval(timerId); finalScoreEl.textContent=score; end.classList.add('active'); }

    function tick(){
      const now=performance.now();
      rafId=requestAnimationFrame(tick);
      if(!running) return;
      ctx.clearRect(0,0,canvas.width,canvas.height);

      if((now-lastSpawn>SPAWN_EVERY) && (sweets.filter(s=>!s.hit).length<MAX_SWEETS)){
        spawnSweet(); lastSpawn=now;
      }
      const dt=1/60; updateAndDrawSweets(dt, now);

      let c=null, radius=0, openness=0, sawFace=false;
      try{
        if(!usePointerMode && faceLandmarker && video.readyState>=2 && video.videoWidth>0){
          const face=faceLandmarker.detectForVideo(video, now);
          if(face?.faceLandmarks?.length){
            sawFace=true;
            const lm=face.faceLandmarks[0];
            openness=mouthOpenMetric(lm);
            const centerN=mouthCenter(lm);
            c=worldToCanvas(centerN);
            radius=Math.max(28, openness*520);
          }
        }
      }catch(err){
        console.warn('detectForVideo error', err);
      }

      if(!sawFace && !usePointerMode){
        faceStatus.textContent = 'Face: not found';
      } else if(usePointerMode){
        faceStatus.textContent = 'Face: pointer mode';
      } else {
        faceStatus.textContent = 'Face: tracking';
      }

      if(!c){
        // fallback to pointer if needed
        c={x:pointer.x, y:pointer.y};
        openness = pointer.down?0.12:0.04;
        radius=Math.max(28, openness*520);
      }

      if(c){
        if(showDebug) drawMouthCircle(c.x,c.y,radius);
        if(openness>OPEN_THRESHOLD) collideWithMouth(c.x,c.y,radius*0.85, now);
      }
    }

    // ---------- Wire UI ----------
    btnStart.addEventListener('click', async ()=>{
      ensureAudio();
      try { await initCamera(); } catch (err) {
        console.error('Camera init failed', err);
        return showToast(err?.message==='InsecureContext' ? 'Use HTTPS or localhost to enable camera.' : 'Camera blocked. Allow access and tap Start again.');
      }
      try { await initFace(); } catch (err) {
        console.warn('Face model failed; pointer fallback', err);
        usePointerMode = true;
        showToast('Face tracking unavailable. Using pointer mode.');
      }
      // Delay to ensure first frame is ready before detection (Safari fix)
      setTimeout(start, 150);
    });

    btnMute.addEventListener('click', ()=>{ muted=!muted; btnMute.textContent=muted? 'Unmute':'Mute'; });
    btnDebug.addEventListener('click', ()=>{ showDebug=!showDebug; showToast(showDebug? 'Debug ON':'Debug OFF', 1000); });

    // Pointer fallback (desktop/testing)
    window.addEventListener('pointermove',(e)=>{ const r=canvas.getBoundingClientRect(); pointer.x=e.clientX-r.left; pointer.y=e.clientY-r.top; });
    window.addEventListener('pointerdown',()=>{ pointer.down=true; });
    window.addEventListener('pointerup',()=>{ pointer.down=false; });

    // Preload face model quietly; don't request camera until user gesture
    (async()=>{ try{ await initFace(); }catch(e){ console.warn('face preload fail',e);} resize(); })();
  </script>
</body>
</html>
