<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>HUT 3 – AR Candy Catcher</title>
  <style>
    :root{
      --brand:#111827; /* HUT 3 dark (tweak me) */
      --accent:#ff3e7f; /* accent for UI */
      --good:#16a34a;
      --bad:#ef4444;
    }
    html,body{margin:0;padding:0;height:100%;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    #app{position:fixed;inset:0;overflow:hidden;background:#000;}
    video#cam{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);display:none;} /* hidden until permission granted */
    canvas#game{position:absolute;inset:0;width:100%;height:100%;}
    .hud{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:12px 14px;pointer-events:none;}
    .badge{pointer-events:auto;background:rgba(0,0,0,.55);color:#fff;padding:6px 10px;border-radius:12px;font-weight:600;backdrop-filter:blur(6px)}
    .score{font-size:18px}
    .timer{font-variant-numeric:tabular-nums}
    .controls{position:absolute;right:12px;bottom:12px;display:flex;gap:8px}
    button{pointer-events:auto;border:none;border-radius:999px;padding:10px 14px;background:var(--accent);color:#fff;font-weight:700;box-shadow:0 8px 24px rgba(0,0,0,.3);cursor:pointer}
    button.secondary{background:rgba(0,0,0,.55)}

    /* Branding frame */
    .frame{position:absolute;inset:0;border:10px solid var(--brand); box-shadow: inset 0 0 0 2px rgba(255,255,255,.06); pointer-events:none}
    .logo{position:absolute;left:12px;bottom:12px;background:var(--brand);color:#fff;padding:8px 12px;border-radius:10px;font-weight:900;letter-spacing:0.5px}

    /* Overlays */
    .overlay{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(0deg,rgba(0,0,0,.75),rgba(0,0,0,.35));color:#fff;text-align:center;padding:24px}
    .card{background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.1);border-radius:16px;padding:20px;max-width:560px}
    .title{font-size:28px;margin:0 0 6px 0}
    .subtitle{opacity:.9;margin:0 0 14px 0}
    .list{opacity:.85;text-align:left;margin:10px auto 16px;max-width:460px}
    .error{color:var(--bad);margin-top:8px}

    /* End / lead gen */
    .end{position:absolute;inset:0;display:none;place-items:center;background:linear-gradient(0deg,rgba(0,0,0,.75),rgba(0,0,0,.35));}
    .end.active{display:grid}
    .end .card h2{margin:0 0 8px 0}
    .input{display:flex;gap:10px;margin-top:10px}
    .input input{flex:1;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.15);background:rgba(0,0,0,.4);color:#fff}
    .small{font-size:12px;opacity:.8;margin-top:8px}

    /* Debug landmarks toggle */
    #dbg{position:absolute;left:12px;top:50%;transform:translateY(-50%);background:rgba(0,0,0,.55);color:#fff;padding:6px 10px;border-radius:10px;display:none}
    .show-debug #dbg{display:block}
  </style>
</head>
<body>
  <div id="app">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="badge score">Score: <span id="score">0</span></div>
      <div class="badge timer">Time: <span id="time">30</span>s</div>
    </div>

    <div class="controls">
      <button id="btnStart">Start</button>
      <button id="btnMute" class="secondary">Mute</button>
      <button id="btnDebug" class="secondary">Debug</button>
    </div>

    <div class="frame"></div>
    <div class="logo">HUT 3</div>

    <div id="overlay" class="overlay">
      <div class="card">
        <h1 class="title">AR Candy Catcher</h1>
        <p class="subtitle" id="subtitle">Open your mouth to catch falling sweets. 30 seconds. Highest score wins.</p>
        <ul class="list">
          <li>Click <b>Enable camera & play</b> below and allow camera access</li>
          <li>Keep your face centred and move your head to line up sweets</li>
          <li>Open wide to catch!</li>
        </ul>
        <div id="permError" class="error" style="display:none"></div>
        <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
          <button id="btnOverlayStart">Enable camera & play</button>
          <button id="btnFallback" class="secondary" title="Play without camera (pointer to aim, hold click/touch to open mouth)">Play without camera</button>
          <button id="btnRetry" class="secondary" style="display:none">Retry camera</button>
        </div>
        <p class="small" style="margin-top:10px">Troubleshooting: use HTTPS, close other apps using the camera, or check browser Settings → Site settings → Camera.</p>
      </div>
    </div>

    <div id="end" class="end">
      <div class="card" style="max-width:520px">
        <h2>Great job! Your score: <span id="finalScore">0</span></h2>
        <p>Enter the prize draw: submit your email with your score.</p>
        <div class="input">
          <input id="email" type="email" placeholder="you@company.com" required />
          <button id="submitScore">Submit</button>
        </div>
        <div id="msg" class="small"></div>
        <p class="small">By submitting you agree to the prize draw terms and that HUT 3 may contact you about marketing services. You can unsubscribe anytime.</p>
      </div>
    </div>

    <div id="dbg">Debug ON</div>
  </div>

  <!-- MediaPipe Face Landmarker (WASM) -->
  <script type="module">
    import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/vision_bundle.mjs";

    // --- Elements
    const video = document.getElementById('cam');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const timeEl = document.getElementById('time');
    const overlay = document.getElementById('overlay');
    const subtitle = document.getElementById('subtitle');
    const permError = document.getElementById('permError');
    const end = document.getElementById('end');
    const finalScoreEl = document.getElementById('finalScore');
    const emailInput = document.getElementById('email');
    const msg = document.getElementById('msg');
    const btnStart = document.getElementById('btnStart');
    const btnOverlayStart = document.getElementById('btnOverlayStart');
    const btnFallback = document.getElementById('btnFallback');
    const btnRetry = document.getElementById('btnRetry');
    const btnMute = document.getElementById('btnMute');
    const btnDebug = document.getElementById('btnDebug');
    const dbg = document.getElementById('dbg');

    // --- State
    let faceLandmarker; let running=false; let muted=false; let showDebug=false;
    let score=0; let timeLeft=30; let timerId=null; let rafId=null;
    let sweets=[]; let lastSpawn=0; const SPAWN_EVERY=650; // ms
    let usePointerMode=false; // fallback without camera
    let pointer={x:innerWidth/2, y:innerHeight/2, down:false};

    // Audio (simple pop)
    const pop = new Audio(); pop.src = URL.createObjectURL(new Blob([new Uint8Array([82,73,70,70,26,0,0,0,87,65,86,69,102,109,116,32,18,0,0,0,1,0,1,0,68,172,0,0,68,172,0,0,1,0,8,0,100,97,116,97,0,0,0,0])], {type:'audio/wav'}));

    function resize(){ canvas.width = video.videoWidth || innerWidth; canvas.height = video.videoHeight || innerHeight; }

    function secureContextOK(){
      if(location.protocol === 'https:' || location.hostname === 'localhost') return true;
      return false;
    }

    async function requestCameraOnce(){
      if(!navigator.mediaDevices?.getUserMedia){ throw new Error('getUserMedia not supported'); }
      const constraints = { video: { facingMode:'user', width:{ideal:1280}, height:{ideal:720} }, audio:false };
      return await navigator.mediaDevices.getUserMedia(constraints);
    }

    async function initCamera(){
      if(!secureContextOK()) throw new Error('InsecureContext');
      const stream = await requestCameraOnce();
      video.srcObject = stream; await video.play();
      video.style.display='block';
      resize();
      window.addEventListener('resize', resize);
    }

    async function initFace(){
      const filesetResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/wasm");
      faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: { modelAssetPath: "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/wasm/face_landmarker.task" },
        runningMode: 'VIDEO',
        numFaces: 1,
        outputFaceBlendshapes: false,
        outputFacialTransformationMatrixes: false
      });
    }

    function mouthOpenMetric(lm){
      // Use landmarks: upper inner lip (13) and lower inner lip (14). Normalize by distance between nose tip (1) and chin (152) to account for scale.
      const U = lm[13], L = lm[14], nose = lm[1], chin = lm[152];
      const mouthGap = Math.hypot((U.x-L.x),(U.y-L.y));
      const faceLen = Math.hypot((nose.x-chin.x),(nose.y-chin.y));
      return (mouthGap / faceLen);
    }

    function mouthCenter(lm){
      const U = lm[13], L = lm[14];
      return { x:(U.x+L.x)/2, y:(U.y+L.y)/2 };
    }

    function spawnSweet(){
      const size = Math.random()*30+26; // px
      const x = Math.random()*canvas.width;
      const speed = Math.random()*60+120; // px/s
      const rot = Math.random()*Math.PI*2; const rotSpeed=(Math.random()*2-1)*1.5;
      const types = ['🍬','🍭','🍫','🍪'];
      const t = types[Math.floor(Math.random()*types.length)];
      sweets.push({x,y:-40,size,speed,rot,rotSpeed,t,hit:false});
    }

    function updateAndDrawSweets(dt){
      ctx.save();
      ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = '32px system-ui';
      for(let i=sweets.length-1;i>=0;i--){
        const s = sweets[i];
        s.y += s.speed * dt; s.rot += s.rotSpeed * dt;
        if(s.y - s.size > canvas.height) { sweets.splice(i,1); continue; }
        ctx.save();
        ctx.translate(s.x, s.y); ctx.rotate(s.rot);
        ctx.font = `${Math.floor(s.size)}px system-ui`;
        ctx.fillText(s.t, 0, 0);
        ctx.restore();
      }
      ctx.restore();
    }

    function drawMouthCircle(mx,my,r){
      ctx.save();
      ctx.strokeStyle = 'rgba(0,255,180,.9)'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(mx,my,r,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    function worldToCanvas(norm){ // normalized [0..1] to canvas, considering mirrored video
      return { x:(1-norm.x)*canvas.width, y:norm.y*canvas.height };
    }

    async function start(){
      overlay.style.display='none'; end.classList.remove('active'); permError.style.display='none';
      score=0; timeLeft=30; sweets=[]; scoreEl.textContent=score; timeEl.textContent=timeLeft;
      running=true; lastSpawn=performance.now();
      tick();
      timerId = setInterval(()=>{ timeLeft--; timeEl.textContent=timeLeft; if(timeLeft<=0) stop(); }, 1000);
    }

    function stop(){
      running=false; cancelAnimationFrame(rafId); clearInterval(timerId);
      finalScoreEl.textContent = score;
      end.classList.add('active');
    }

    function collideWithMouth(mx,my,r){
      for(let i=sweets.length-1;i>=0;i--){
        const s = sweets[i];
        const dx = s.x - mx, dy = s.y - my; const d = Math.hypot(dx,dy);
        if(d < r){ // eaten
          sweets.splice(i,1);
          score++; scoreEl.textContent=score;
          if(!muted){ try{ pop.currentTime=0; pop.play(); }catch(e){} }
        }
      }
    }

    async function tick(){
      const now = performance.now();
      rafId = requestAnimationFrame(tick);
      if(!running) return;

      // Face landmarks (only if not in pointer fallback mode)
      let c=null; let radius=0; let openness=0; let lm=null;
      if(!usePointerMode){
        const face = faceLandmarker && video.readyState>=2 ? faceLandmarker.detectForVideo(video, now) : null;
        if(face && face.faceLandmarks && face.faceLandmarks.length){
          lm = face.faceLandmarks[0];
          openness = mouthOpenMetric(lm); // ~0.04 closed -> >0.09 open (device dependent)
          const centerN = mouthCenter(lm);
          c = worldToCanvas(centerN);
          radius = Math.max(24, openness * 480); // scale to pixels
        }
      } else {
        c = {x: pointer.x, y: pointer.y};
        openness = pointer.down ? 0.12 : 0.04; // hold to "open mouth"
        radius = Math.max(24, openness * 480);
      }

      // Clear/draw background (we draw only game layer; camera is the <video> below)
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Spawn sweets
      if(now - lastSpawn > SPAWN_EVERY){ spawnSweet(); lastSpawn=now; }

      // Update sweets
      const dt = 1/60; // fixed step for simplicity
      updateAndDrawSweets(dt);

      // Mouth logic
      if(c){
        if(showDebug){ drawMouthCircle(c.x, c.y, radius); }
        if(openness > 0.075){ collideWithMouth(c.x, c.y, radius*0.85); }
        if(showDebug){ dbg.textContent = `Open: ${openness.toFixed(3)} r=${Math.round(radius)}`; }
      }
    }

    // Lead submit
    async function submitLead(){
      const email = (emailInput.value||'').trim();
      if(!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)){ msg.textContent='Please enter a valid email.'; msg.style.color='var(--bad)'; return; }
      msg.textContent='Submitting…'; msg.style.color='#fff';
      try{
        // Replace with your backend endpoint (Netlify Function, Vercel, or HubSpot/Mailchimp API proxy)
        const res = await fetch('/api/submit-score', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ email, score, game:'ar-candy-catcher', ts: new Date().toISOString() }) });
        if(!res.ok) throw new Error('Network');
        msg.textContent='Thanks! You’re in the draw.'; msg.style.color='var(--good)';
      }catch(e){ msg.textContent='Could not submit right now. Please try again.'; msg.style.color='var(--bad)'; }
    }

    // --- Permissions helpers & error UI ---
    function showPermError(text, showRetry=true){
      permError.textContent = text; permError.style.display='block';
      btnRetry.style.display = showRetry? 'inline-block' : 'none';
      overlay.style.display='grid';
    }

    async function ensurePermissionsAndStart(){
      try{
        // Optional preflight with Permissions API
        if(navigator.permissions?.query){
          try{ const p = await navigator.permissions.query({ name: 'camera' }); if(p.state === 'denied'){ throw new DOMException('Permission denied', 'NotAllowedError'); } }catch(_){/* ignore unsupported */}
        }
        await initCamera();
        if(!faceLandmarker) await initFace();
        start();
      } catch(err){
        console.warn('Camera init failed', err);
        let help = 'Camera permission denied. Please allow camera access in your browser settings and try again.';
        if(err?.name === 'NotAllowedError' || err?.name === 'SecurityError'){
          help = 'Camera access was blocked. Click the address bar camera icon to allow access, then press Retry.';
        } else if(err?.message === 'InsecureContext'){
          help = 'Camera requires HTTPS (or localhost). Please host this page over HTTPS and Retry.';
        } else if(err?.name === 'NotFoundError'){
          help = 'No camera found. Connect a camera or use another device, or Play without camera.';
        } else if(err?.message?.includes('getUserMedia not supported')){
          help = 'This browser does not support camera access. Try a recent Safari/Chrome on mobile, or Play without camera.';
        }
        showPermError(help);
      }
    }

    // Wire UI
    btnStart.addEventListener('click', ()=>{ overlay.style.display='grid'; });
    btnOverlayStart.addEventListener('click', ensurePermissionsAndStart);
    btnRetry.addEventListener('click', ensurePermissionsAndStart);
    btnFallback.addEventListener('click', ()=>{ usePointerMode=true; video.style.display='none'; start(); });
    btnMute.addEventListener('click', ()=>{ muted=!muted; btnMute.textContent = muted? 'Unmute':'Mute'; });
    btnDebug.addEventListener('click', ()=>{ showDebug=!showDebug; document.body.classList.toggle('show-debug', showDebug); });
    document.getElementById('submitScore').addEventListener('click', submitLead);

    // Pointer fallback controls
    window.addEventListener('pointermove', (e)=>{ const rect = canvas.getBoundingClientRect(); pointer.x = e.clientX - rect.left; pointer.y = e.clientY - rect.top; });
    window.addEventListener('pointerdown', ()=>{ pointer.down=true; });
    window.addEventListener('pointerup', ()=>{ pointer.down=false; });
    window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ pointer.down=true; } });
    window.addEventListener('keyup', (e)=>{ if(e.code==='Space'){ pointer.down=false; } });

    // Boot (lazy-load face model early, but do not request camera until user gesture)
    (async ()=>{
      try{ await initFace(); }catch(err){ console.warn('Face model load failed', err); subtitle.textContent='Face tracking failed to load. You can still play in pointer mode.'; }
      // Resize canvas to viewport initially
      resize();
    })();
  </script>
</body>
</html>
